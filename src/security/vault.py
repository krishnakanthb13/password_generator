"""
Vault Module - Handles encryption for secure history storage.
"""

import os
import base64
import logging
import hashlib
import sys
from pathlib import Path
from typing import Optional
from dotenv import load_dotenv

# Load environment variables from .env if present
load_dotenv()

# Setup logger
logger = logging.getLogger(__name__)

try:
    from cryptography.fernet import Fernet, InvalidToken
    from cryptography.hazmat.primitives import hashes
    from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
    CRYPTOGRAPHY_AVAILABLE = True
except ImportError:
    CRYPTOGRAPHY_AVAILABLE = False


class Vault:
    """Manages encryption keys and secure data transformation."""
    
    def __init__(self, vault_dir: Optional[Path] = None):
        """Initialize vault with a storage directory."""
        if vault_dir:
            self.vault_dir = vault_dir
        else:
            self.vault_dir = Path.home() / ".passforge"
            
        self.vault_dir.mkdir(parents=True, exist_ok=True)
        self.key_file = self.vault_dir / ".vault.key"
        self._fernet = None
        self._legacy_fernet = None
        
        if CRYPTOGRAPHY_AVAILABLE:
            self._init_fernet()

    def _init_fernet(self):
        """
        Initialize the Fernet encryption instance.
        Prioritizes PASSFORGE_API_KEY from environment/.env.
        Also loads a legacy key if present for decryption compatibility.
        """
        api_key = os.getenv("PASSFORGE_API_KEY")
        
        # 1. Initialize primary Fernet from API Key
        if api_key:
            key_bytes = hashlib.sha256(api_key.encode()).digest()
            primary_key = base64.urlsafe_b64encode(key_bytes)
            try:
                self._fernet = Fernet(primary_key)
            except Exception as e:
                logger.error(f"Failed to initialize primary Fernet: {e}")

        # 2. Initialize legacy Fernet from file (for decryption fallback)
        if self.key_file.exists():
            try:
                with open(self.key_file, 'rb') as f:
                    legacy_key = f.read()
                self._legacy_fernet = Fernet(legacy_key)
                
                # If no primary was set (no .env yet), use legacy as primary to maintain usage
                if not self._fernet:
                    self._fernet = self._legacy_fernet
            except Exception as e:
                logger.warning(f"Could not load legacy key: {e}")

    @staticmethod
    def ensure_secure_mode() -> bool:
        """
        Ensure the user has an encryption key set.
        Returns True if key is set, False if not.
        """
        from colorama import Fore, Style
        vault = Vault()
        if vault.is_active:
            return True
            
        print(f"\n{Fore.YELLOW}⚠️  Security Warning: No Encryption Key Found!{Style.RESET_ALL}")
        print("To securely store and view your password history, you must set an encryption key.")
        print("\nHow to fix:")
        print(f"1. Create a {Fore.CYAN}.env{Style.RESET_ALL} file in the project root.")
        print(f"2. Add {Fore.GREEN}PASSFORGE_API_KEY=your_strong_secret{Style.RESET_ALL} to it.")
        
        # Try to offer auto-generation if in a TTY
        if sys.stdin.isatty():
            print(f"\nWould you like me to generate a secure key for you in a .env file? (y/n)")
            try:
                choice = input("> ").lower().strip()
                if choice == 'y':
                    import secrets
                    key = secrets.token_urlsafe(32)
                    try:
                        with open(".env", "a") as f:
                            f.write(f"\n# Generated by PassForge\nPASSFORGE_API_KEY={key}\n")
                        # Reload env
                        from dotenv import load_dotenv
                        load_dotenv()
                        # Re-verify
                        if Vault().is_active:
                            print(f"{Fore.GREEN}[OK] .env file updated with a new secure key.{Style.RESET_ALL}")
                            return True
                    except Exception as e:
                        print(f"{Fore.RED}[ERR] Failed to write to .env: {e}{Style.RESET_ALL}")
            except (KeyboardInterrupt, EOFError):
                print()
                
        print(f"{Fore.YELLOW}History features are disabled until a key is set.{Style.RESET_ALL}")
        return False

    @property
    def is_active(self) -> bool:
        """Check if encryption is available and initialized."""
        return CRYPTOGRAPHY_AVAILABLE and self._fernet is not None

    def encrypt(self, text: str, strict: bool = False) -> str:
        """
        Encrypt a string. 
        Falling back to plaintext by default unless strict=True.
        """
        if not self.is_active or not text:
            if strict and text:
                raise RuntimeError("Vault is not active, cannot encrypt strictly")
            return text
            
        try:
            encrypted = self._fernet.encrypt(text.encode('utf-8'))
            return encrypted.decode('ascii')
        except (InvalidToken, Exception) as e:
            logger.warning(f"Encryption failed: {e}")
            if strict:
                raise
            return text

    def decrypt(self, encrypted_text: str, strict: bool = False) -> str:
        """
        Decrypt a base64 encoded string.
        Tries primary key first, then legacy key fallback.
        """
        if not self.is_active or not encrypted_text:
            if strict and encrypted_text:
                raise RuntimeError("Vault is not active, cannot decrypt strictly")
            return encrypted_text
            
        # Try Primary Key
        try:
            decrypted = self._fernet.decrypt(encrypted_text.encode('ascii'))
            return decrypted.decode('utf-8')
        except (InvalidToken, Exception):
            # If primary fails, try Legacy Key
            if self._legacy_fernet and self._legacy_fernet != self._fernet:
                try:
                    decrypted = self._legacy_fernet.decrypt(encrypted_text.encode('ascii'))
                    return decrypted.decode('utf-8')
                except (InvalidToken, Exception):
                    pass
            
            # Final fallback: return as-is if not strict
            if strict:
                logger.error("Decryption failed strictly")
                raise RuntimeError("Decryption failed")
            
            # Silent fallback for non-strict (prevents log flood during UI rendering)
            return encrypted_text
